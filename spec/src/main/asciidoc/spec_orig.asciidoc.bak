[chapter]

 _Version 1.0 Early Draft (Second Edition) +
_

Editors: +
Santiago Pericas-Geertsen +
Manfred Riem +
Christian Kaltepoth +
Comments to: jsr371-users@googlegroups.com

_Ivar Grimstad & Christian Kaltepoth_

[[introduction]]
Introduction
------------

Model-View-Controller, or _MVC_ for short, is a common pattern in Web
frameworks where it is used predominantly to build HTML applications.
The _model_ refers to the application’s data, the _view_ to the
application’s data presentation and the _controller_ to the part of the
system responsible for managing input, updating models and producing
output.

Web UI frameworks can be categorized as _action-based_ or
_component-based_. In an action-based framework, HTTP requests are
routed to controllers where they are turned into actions by application
code; in a component-based framework, HTTP requests are grouped and
typically handled by framework components with little or no interaction
from application code. In other words, in a component-based framework,
the majority of the controller logic is provided by the framework
instead of the application.

The API defined by this specification falls into the action-based
category and is, therefore, not intended to be a replacement for
component-based frameworks such as JavaServer Faces (JSF) , but simply a
different approach to building Web applications on the Java EE platform.

[[goals]]
Goals
~~~~~

The following are goals of the API:

Goal 1::
  Leverage existing Java EE technologies.
Goal 2::
  Integrate with CDI and Bean Validation .
Goal 3::
  Define a solid core to build MVC applications without necessarily
  supporting all the features in its first version.
Goal 4::
  Explore layering on top of JAX-RS for the purpose of re-using its
  matching and binding layers.
Goal 5::
  Provide built-in support for JSPs and Facelets view languages.

[[non_goals]]
Non-Goals
~~~~~~~~~

The following are non-goals of the API:

Non-Goal 1::
  Define a new view (template) language and processor.
Non-Goal 2::
  Support standalone implementations of MVC running outside of Java EE.
Non-Goal 3::
  Support REST services not based on JAX-RS.
Non-Goal 4::
  Provide built-in support for view languages that are not part of Java
  EE.

It is worth noting that, even though a standalone implementation of
MVC that runs outside of Java EE is a non-goal, this specification shall
not intentionally prevent implementations to run in other environments,
provided that those environments include support for all the EE
technologies required by MVC.

[[additional_information]]
Additional Information
~~~~~~~~~~~~~~~~~~~~~~

The issue tracking system for this specification can be found at:

___________________________________________
https://github.com/mvc-spec/mvc-spec/issues
___________________________________________

The corresponding Javadocs can be found online at:

_________________________
https://www.mvc-spec.org/
_________________________

The reference implementation can be obtained from:

_______________________________
https://www.mvc-spec.org/ozark/
_______________________________

The expert group seeks feedback from the community on any aspect of this
specification, please send comments to:

_____________________________
jsr371-users@googlegroups.com
_____________________________

[[terminology]]
Terminology
~~~~~~~~~~~

Most of the terminology used in this specification is borrowed from
other specifications such as JAX-RS and CDI. We use the terms
_per-request_ and _request-scoped_ as well as _per-application_ and
_application-scoped_ interchangeably.

[[conventions]]
Conventions
~~~~~~~~~~~

The keywords `MUST', `MUST NOT', `REQUIRED', `SHALL', `SHALL NOT',
`SHOULD', `SHOULD NOT', `RECOMMENDED', `MAY', and `OPTIONAL' in this
document are to be interpreted as described in RFC 2119.

Assertions defined by this specification are formatted as
*latexmath:[$[\![$]an-assertionlatexmath:[$]\!]$]* using a descriptive
name as the label and are all listed in Appendix [assertions].

Java code and sample data fragments are formatted as shown in figure
[ex1]:

1 package com.example.hello;

public class Hello public static void main(String args[])
System.out.println(``Hello World'');

URIs of the general form `http://example.org/...' and
`http://example.com/...' represent application or context-dependent
URIs.

All parts of this specification are normative, with the exception of
examples, notes and sections explicitly marked as `Non-Normative'.
Non-normative notes are formatted as shown below.

This is a note.

[[expert_group]]
Expert Group Members
~~~~~~~~~~~~~~~~~~~~

This specification is being developed as part of JSR 371 under the Java
Community Process. The following are the present expert group members:

latexmath:[$-$]0em 0em

Mathieu Ancelin (Individual Member)

Ivar Grimstad (Individual Member)

Neil Griffin (Liferay, Inc)

Joshua Wilson (RedHat)

Rodrigo Turini (Caelum)

Stefan Tilkov (innoQ Deutschland GmbH)

Guilherme de Azevedo Silveira (Individual Member)

Frank Caputo (Individual Member)

Christian Kaltepoth (ingenit GmbH & Co. KG)

Woong-ki Lee (TmaxSoft, Inc.)

Paul Nicolucci (IBM)

Kito D. Mann (Individual Member)

Rahman Usta (Individual Member)

[[acks]]
Acknowledgements
~~~~~~~~~~~~~~~~

During the course of this JSR we received many excellent suggestions.
Special thanks to Marek Potociar, Dhiru Pandey and Ed Burns, all from
Oracle. In addition, to everyone in the user’s alias that followed the
expert discussions and provided feedback, including Peter Pilgrim, Ivar
Grimstad, Jozef Hartinger, Florian Hirsch, Frans Tamura, Rahman Usta,
Romain Manni-Bucau, Alberto Souza, among many others.

[[mvc]]
Models, Views and Controllers
-----------------------------

This chapter introduces the three components that comprise the
MVC architectural pattern: models, views and controllers.

[[controllers]]
Controllers
~~~~~~~~~~~

An _MVC controller_ is a JAX-RS  resource method decorated by
`@Controller` *latexmath:[$[\![$][mvc:controller]latexmath:[$]\!]$]*. If
this annotation is applied to a class, then all resource methods in it
are regarded as controllers
*latexmath:[$[\![$][mvc:all-controllers]latexmath:[$]\!]$]*. Using the
`@Controller` annotation on a subset of methods defines a hybrid class
in which certain methods are controllers and others are traditional
JAX-RS resource methods.

A simple hello-world controller can be defined as follows:

1 @Path(``hello'') public class HelloController

@GET @Controller public String hello() return ``hello.jsp'';

In this example, `hello` is a controller method that returns a path to a
JavaServer Page (JSP). The semantics of controller methods differ
slightly from JAX-RS resource methods; in particular, a return type of
`String` is interpreted as a view path rather than text content.
Moreover, the default media type for a response is assumed to be
`text/html`, but otherwise can be declared using `@Produces` just like
in JAX-RS.

A controller’s method return type determines how its result is
processed:

void::
  A controller method that returns void is REQUIRED to be decorated by
  `@View`*latexmath:[$[\![$][mvc:void-controllers]latexmath:[$]\!]$]*.
String::
  A string returned is interpreted as a view path.
Viewable::
  A `Viewable` is a class that encapsulates a view path as well as
  additional information related to its processing.
_(Java Type)_::
  The method `toString` is called on other Java types and the result
  interpreted as a view path.
Response::
  A JAX-RS `Response` whose entity’s type is one of the above.

The following class defines equivalent controller methods:

1 @Controller @Path(``hello'') public class HelloController

@GET @Path(``void'') @View(``hello.jsp'') public void helloVoid()

@GET @Path(``string'') public String helloString() return ``hello.jsp'';

@GET @Path(``viewable'') public Viewable helloViewable() return new
Viewable(``hello.jsp'');

@GET @Path(``response'') public Response helloResponse() return
Response.status(Response.Status.OK) .entity(``hello.jsp'').build();

@GET @Path(``myview'') public MyView helloMyView() return new
MyView(``hello.jsp''); // toString() -> ``hello.jsp''

Controller methods that return a non-void type may also be decorated
with `@View` as a way to specify a _default_ view for the controller.
The default view MUST be used only when such a non-void controller
method returns a `null` value
*latexmath:[$[\![$][mvc:null-controllers]latexmath:[$]\!]$]*.

Note that, even though controller methods return types are restricted as
explained above, MVC does not impose any restrictions on parameter types
available to controller methods: i.e., all parameter types injectable in
JAX-RS resources are also available in MVC controllers. Likewise,
injection of fields and properties is unrestricted and fully compatible
with JAX-RS —modulo the restrictions explained in Section
[controller_instances].

Controller methods handle a HTTP request directly. Sub-resource locators
as described in the JAX-RS Specification are not supported by MVC.

[[controller_instances]]
Controller Instances
^^^^^^^^^^^^^^^^^^^^

Unlike in JAX-RS where resource classes can be native (created and
managed by JAX-RS), CDI beans, managed beans or EJBs, MVC classes are
REQUIRED to be CDI-managed beans only
*latexmath:[$[\![$][mvc:cdi-beans]latexmath:[$]\!]$]*. It follows that a
hybrid class that contains a mix of JAX-RS resource methods and
MVC controllers must also be CDI managed.

Like in JAX-RS, the default resource class instance lifecycle is
_per-request_ *latexmath:[$[\![$][mvc:per-request]latexmath:[$]\!]$]*.
That is, an instance of a controller class MUST be instantiated and
initialized on every request. Implementations MAY support other
lifecycles via CDI; the same caveats that apply to JAX-RS classes in
other lifecycles applied to MVC classes. footnote:[In particular, CDI
may need to create proxies when, for example, a per-request instance is
as a member of a per-application instance.] See for more information on
lifecycles and their caveats.

[[viewable]]
Viewable
^^^^^^^^

The `Viewable` class encapsulates information about a view as well as,
optionally, information about how it should be processed. More
precisely, a `Viewable` instance may include references to `Models` and
`ViewEngine` objects —for more information see Section [models] and
Chapter [view_engines], respectively. `Viewable` defines traditional
constructors for all these objects and it is, therefore, not a
CDI-managed bean.

The reader is referred to the Javadoc of the `Viewable` class for more
information on its semantics.

[[response]]
Response
^^^^^^^^

Returning a `Response` object gives applications full access to all the
parts in a response, including the headers. For example, an instance of
`Response` can modify the HTTP status code upon encountering an error
condition; JAX-RS provides a fluent API to build responses as shown
next.

1 @GET @Controller public Response getById(@PathParam(``id'') String id)
if (id.length() == 0) return
Response.status(Response.Status.BAD_REQUEST)
.entity(``error.jsp'').build(); ...

Direct access to `Response` enables applications to override content
types, set character encodings, set cache control policies, trigger an
HTTP redirect, etc. For more information, the reader is referred to the
Javadoc for the `Response` class.

[[redirect]]
Redirect and @RedirectScoped
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

As stated in the previous section, controllers can redirect clients by
returning a `Response`instance using the JAX-RS API. For example,

1 @GET @Controller public Response redirect() return
Response.seeOther(URI.create(``see/here'')).build();

Given the popularity of the POST-redirect-GET pattern, MVC
implementations are REQUIRED to support view paths prefixed by redirect:
as a more concise way to trigger a client redirect
*latexmath:[$[\![$][mvc:redirect]latexmath:[$]\!]$]*. Using this prefix,
the controller shown above can be re-written as follows:

1 @GET @Controller public String redirect() return
``redirect:see/here'';

In either case, the HTTP status code returned is 302 and relative paths
are resolved relative to the application path –for more information
please refer to the Javadoc for the seeOther method in JAX-RS. It is
worth noting that redirects require client cooperation (all browsers
support it, but certain CLI clients may not) and result in a completely
new request-response cycle in order to access the intended controller.

MVC applications can leverage CDI by defining beans in scopes such as
request and session. A bean in request scope is available only during
the processing of a single request, while a bean in session scope is
available throughout an entire web session which can potentially span
tens or even hundreds of requests.

Sometimes it is necessary to share data between the request that returns
a redirect instruction and the new request that is triggered as a
result. That is, a scope that spans at most two requests and thus fits
between a request and a session scope. For this purpose, the MVC API
defines a new CDI scope identified by the annotation @RedirectScoped.
CDI beans in this scope are automatically created and destroyed by
correlating a redirect and the request that follows. The exact mechanism
by which requests are correlated is implementation dependent, but
popular techniques include URL rewrites and cookies.

Let us assume that MyBean is annotated by @RedirectScoped and given the
name mybean, and consider the following controller:

1 @Controller @Path(``submit'') public class MyController

@Inject private MyBean myBean;

@POST public String post() myBean.setValue(``Redirect about to
happen''); return ``redirect:/submit'';

@GET public String get() return ``mybean.jsp''; // mybean.value accessed
in JSP

The bean myBean is injected in the controller and available not only
during the first POST, but also during the subsequent GET request,
enabling _communication_ between the two interactions; the creation and
destruction of the bean is under control of CDI, and thus completely
transparent to the application just like any other built-in scope.

[[models]]
Models
~~~~~~

MVC controllers are responsible for combining data models and views
(templates) to produce web application pages. This specification
supports two kinds of models: the first is based on CDI `@Named` beans,
and the second on the `Models` interface which defines a map between
names and objects. Support for the `Models`  interface is mandatory for
all view engines; support for CDI `@Named` beans is OPTIONAL but highly
RECOMMENDED. Application developers are encouraged to use CDI-based
models whenever supported by the view engine, and thus take advantage of
the existing CDI and EL integration on the platform.

Let us now revisit our hello-world example, this time also showing how
to update a model. Since we intend to show the two ways in which models
can be used, we define the model as a CDI `@Named` bean in request scope
even though this is only necessary for the CDI case:

1 @Named(``greeting'') @RequestScoped public class Greeting

private String message;

public String getMessage() return message; public void setMessage(String
message) this.message = message; ...

Given that the view engine for JSPs supports `@Named` beans, all the
controller needs to do is fill out the model and return the view. Access
to the model is straightforward using CDI injection:

1 @Path(``hello'') public class HelloController

@Inject private Greeting greeting;

@GET @Controller public String hello() greeting.setMessage(``Hello
there!''); return ``hello.jsp'';

If the view engine that processes the view returned by the controller is
not CDI enabled, then controllers can use the `Models` map instead:

1 @Path(``hello'') public class HelloController

@Inject private Models models;

@GET @Controller public String hello() models.put(``greeting'', new
Greeting(``Hello there!''); return ``hello.jsp'';

In this example, the model is given the same name as that in the
`@Named` annotation above, but using the injectable `Models` map
instead.

As stated above, the use of typed CDI `@Named` beans is recommended over
the `Models` map, but support for the latter may be necessary to
integrate view engines that are not CDI aware. For more information
about view engines see Chapter [view_engines].

[[views]]
Views
~~~~~

A _view_, sometimes also referred to as a template, defines the
structure of the output page and can refer to one or more models. It is
the responsibility of a _view engine_ to process (render) a view by
extracting the information in the models and producing the output page.

Here is the JSP page for the hello-world example:

1 <<!doctype html> <html> <head> <title>Hello</title> </head> <body>
<h1>latexmath:[${greeting.message}</h1>
</body>
</html>
\end{listing}

In a JSP, model properties are accessible via EL \cite{el}. In the example above,
the property {\texttt{\small message}} is read from the {\texttt{\small greeting}} model whose name
was either specified in a {{\texttt{\small @Named}}}\ annotation or used as a key in the {{\texttt{\small Models}}}\ map, 
depending on which controller from Section \ref{models} triggered this view's 
processing.

Here is the corresponding Facelets example:

\begin{listing}{1}
<!DOCTYPE html>
<html lang="en" xmlns:h="http://xmlns.jcp.org/jsf/html">
<h:head>
    <title>Hello</title>
</h:head>
<h:body>
    <h:outputText value="#{greeting.message}" />
</h:body>
</html>
\end{listing}

{\@startsection{subsection}{2}{0pt}                                     {-3.25ex\@plus -1ex \@minus -.2ex}                                     {1.5ex \@plus .2ex}                                     {\sffamily\large\bfseries}}{Building URIs in a View}
\label{mvc_uri}

In views links and form actions require a URI. To avoid repeating the declarative
mapping to URIs on controller methods MVC provides a way to build URIs from the
{\tt MvcContext}:

\begin{listing}{1}
$]mvc.uri(’MyController#myMethod’ ’id’: 42, ’foo’: ’bar’)

The controller method can either be identified by the simple name of the
controller class and the method name separated by #
(MyController#myMethod) _or_ by the value of the @UriRef annotation.
Please refer to the Javadocs of MvcContext for a full description of the
different ways to provide parameter values for building URIs.

[[exception_handling]]
Exception Handling
------------------

This chapter discusses exception handling in the MVC API. Exception
handling in MVC is based on the underlying mechanism provided by JAX-RS,
but with additional support for handling binding and validation
exceptions that are common in MVC frameworks.

[[exception_mappers]]
Exception Mappers
~~~~~~~~~~~~~~~~~

The general exception handling mechanism in MVC  controllers is
identical to that defined for resource methods in the
JAX-RS specification. In a nutshell, applications can implement
exception mapping providers for the purpose of converting exceptions to
responses. If an exception mapper is not found for a particular
exception type, default rules apply that describe how to process the
exception depending on whether it is checked or unchecked, and using
additional rules for the special case of a
`WebApplicationException` that includes a response. The reader is
referred to the JAX-RS specification for more information.

Let us consider the case of a `ConstraintViolationException` that is
thrown as a result of a bean validation failure:

1 @Controller @Path(``form'') public class FormController

@POST public Response formPost(@Valid @BeanParam FormDataBean form)
return Response.status(OK).entity(``data.jsp'').build();

The method `formPost` defines a bean parameter of type `FormDataBean`
which, for the sake of the example, we assume includes validation
constraints such as `@Min(18)`, `@Size(min=1)`, etc. The presence of
`@Valid` triggers validation of the bean on every HTML form post; if
validation fails, a `ConstraintViolationException` (a subclass of
`ValidationException`) is thrown.

An application can handle the exception by including an exception mapper
as follows:

1 public class FormViolationMapper implements
ExceptionMapper<ConstraintViolationException>

@Inject private ErrorDataBean error;

@Override public Response toResponse(ConstraintViolationException e)
final Set<ConstraintViolation<?>> set = e.getConstraintViolations(); if
(!set.isEmpty()) // fill out ErrorDataBean ... return
Response.status(Response.Status.BAD_REQUEST)
.entity(``error.jsp'').build();

This exception mapper updates an instance of `ErrorDataBean` and returns
the `error.jsp` view (wrapped in a response as required by the method
signature) with the intent to provide a human-friendly description of
the exception.

Even though using exception mappers is a convenient way to handle
exceptions in general, there are cases in which finer control is
necessary. The mapper defined above will be invoked for all instances of
`ConstraintViolationException` thrown in an application. Given that
applications may include several form-post controllers, handling all
exceptions in a single location makes it difficult to provide
controller-specific customizations. Moreover, exception mappers do not
get access to the (partially valid) bound data, or `FormDataBean` in the
example above.

[[validation_exceptions]]
Validation Exceptions
~~~~~~~~~~~~~~~~~~~~~

MVC provides an alternative exception handling mechanism that is
specific for the use case described in Section [exception_mappers].
Rather than funnelling exception handling into a single location while
providing no access to the bound data, controller methods may opt to act
as exception handlers as well. In other words, controller methods can
get called even if parameter validation fails as long as they declare
themselves capable of handling errors.

A controller class that, either directly or indirectly via inheritance,
defines a field or a property of type `javax.mvc.binding.BindingResult`
will have its controller methods called even if an error is encountered
while validating parameters. Implementations MUST introspect the
controller bean for a field or a property of this type to determine the
correct semantics; fields and property setters of this type MUST be
annotated with `@Inject` to guarantee proper bean initialization
*latexmath:[$[\![$][mvc:validation-result]latexmath:[$]\!]$]*.

Let us revisit the example from Section [exception_mappers], this time
using the controller method as an exception handler:

1 @Controller @Path(``form'') public class FormController

@Inject private BindingResult br;

@Inject private ErrorDataBean error;

@POST @ValidateOnExecution(type = ExecutableType.NONE) public Response
formPost(@Valid @BeanParam FormDataBean form) if (br.isFailed()) // fill
out ErrorDataBean ... return
Response.status(BAD_REQUEST).entity(``error.jsp'').build(); return
Response.status(OK).entity(``data.jsp'').build();

The presence of the injection target for the field `br` indicates to an
implementation that controller methods in this class can handle errors.
As a result, methods in this class that validate parameters should call
`br.isFailed()` to verify if validation errors were found. footnote:[The
`ValidateOnExecution` annotation is necessary to ensure that CDI and BV
do not abort the invocation upon detecting a violation. Thus, to ensure
the correct semantics, validation must be performed by the JAX-RS
implementation before the method is called.]

The class `BindingResult` provides methods to get detailed information
about any violations found during validation. Instances of this class
are always in request scope; the reader is referred to the Javadoc for
more information.

As previously stated, properties of type `BindingResult` are also
supported. Here is a modified version of the example in which a property
is used instead:

1 @Controller @Path(``form'') public class FormController

private BindingResult br;

public BindingResult getBr() return br;

@Inject public void setBr(BindingResult br) this.br = br; ...

Note that the `@Inject` annotation has been moved from the field to the
setter, thus ensuring the bean is properly initialized by CDI when it is
created. Implementations MUST give precedence to a property (calling its
getter and setter) over a field if both are present in the same class.

[[binding_exceptions]]
Binding Exceptions
~~~~~~~~~~~~~~~~~~

As suggested by its name, instances of `BindingResult` also track any
binding errors that occur while mapping request parameters to Java
types. Binding errors are discovered even before validation takes place.
An example of a binding error is that of a query parameter bound to an
int whose value cannot be converted to that type.

JAX-RS uses the notion of a parameter converter to provide extension
points for these conversions; if none are specified for the type at
hand, a set of default parameter converters is available. Regardless of
where the parameter converter is coming from, a failure to carry out a
conversion results in an `IllegalArgumentException` thrown and,
typically, a 500 error code returned to the client. As explained before,
applications can provide an exception mapper for
`IllegalArgumentException` but this may be insufficient when error
recovery using controller-specific logic is required.

Controllers can call the same `isFailed` method to check for binding
errors —the method returns true if at least one error of either kind is
found. Additional methods in the `BindingResult` type allow to get
specific information related to binding errors. See the Javadoc for more
information.

[[security]]
Security
--------

[[introduction-1]]
Introduction
~~~~~~~~~~~~

Guarding against malicious attacks is a great concern for web
application developers. In particular, MVC applications that accept
input from a browser are often targetted by attackers. Two of the most
common forms of attacks are cross-site request forgery (CSRF) and
cross-site scripting (XSS). This chapter explores techniques to prevent
these type of attacks with the aid of the MVC API.

[[cross-site-request-forgery]]
Cross-site Request Forgery
~~~~~~~~~~~~~~~~~~~~~~~~~~

Cross-site Request Forgery (CSRF) is a type of attack in which a user,
who has a trust relationship with a certain site, is mislead into
executing some commands that exploit the existence of such a trust
relationship. The canonical example for this attack is that of a user
unintentionally carrying out a bank transfer while visiting another
site.

The attack is based on the inclusion of a link or script in a page that
accesses a site to which the user is known or assumed to have been
authenticated (trusted). Trust relationships are often stored in the
form of cookies that may be active while the user is visiting other
sites. For example, such a malicious site could include the following
HTML snippet:

....
<img src="http://yourbank.com/transfer?from=yours&to=mine&sum=1000000">
....

which will result in the browser executing a bank transfer in an attempt
to load an image.

In practice, most sites require the use of form posts to submit requests
such as bank transfers. The common way to prevent CSRF attacks is by
embedding additional, difficult-to-guess data fields in requests that
contain sensible commands. This additional data, known as a token, is
obtained from the trusted site but unlike cookies it is never stored in
the browser.

MVC implementations provide CSRF protection using the Csrf object and
the @CsrfValid annotation. The Csrf object is available to applications
via the injectable MvcContext type or in EL as mvc.csrf. For more
information about MvcContext, please refer to Section [mvc_context].

Applications may use the Csrf object to inject a hidden field in a form
that can be validated upon submission. Consider the following JSP,

1 <html> <head> <title>CSRF Protected Form</title> </head> <body> <form
action=``csrf'' method=``post'' accept-charset=``utf-8''> <input
type=``submit'' value=``Click here''/> <input type=``hidden''
name=``latexmath:[${mvc.csrf.name}" 
                             value="$]mvc.csrf.token''/> </form> </body>
</html>

The hidden field will be submitted with the form, giving the MVC
implementation the opportunity to verify the token and ensure the
validity of the post request.

Another way to convey this information to and from the client is via an
HTTP header. MVC implementations are REQUIRED to support CSRF tokens
both as form fields (with the help of the application developer as shown
above) and as HTTP headers.

The application-level property javax.mvc.security.CsrfProtection enables
CSRF protection when set to one of the possible values defined in
javax.mvc.security.Csrf.CsrfOptions. The default value of this property
is CsrfOptions.EXPLICIT. Any other value than CsrfOptions.OFF will
automatically inject a CSRF token as an HTTP header; the actual name of
this header is implementation dependent.

Automatic validation is enabled by setting this property to
CsrfOptions.IMPLICIT, in which case all post requests must include
either an HTTP header or a hidden field with the correct token. Finally,
if the property is set to CsrfOptions.EXPLICIT then application
developers must annotate controllers using @CsrfValid to manually enable
validation *latexmath:[$[\![$][mvc:csrf-options]latexmath:[$]\!]$]* as
shown in the following example.

1 @Path(``csrf'') @Controller public class CsrfController

@GET public String getForm() return ``csrf.jsp''; // Injects CSRF token

@POST @CsrfValid // Required for CsrfOptions.EXPLICIT public void
postForm(@FormParam(``greeting'') String greeting) // Process greeting

MVC implementations are required to support CSRF validation of tokens
for controllers annotated with @POST and consuming the media type
x-www-form-urlencoded
*latexmath:[$[\![$][mvc:csrf-support]latexmath:[$]\!]$]*; other media
types and scenarios may also be supported but are OPTIONAL.

[[cross-site-scripting]]
Cross-site Scripting
~~~~~~~~~~~~~~~~~~~~

Cross-site scripting (XSS) is a type of attack in which snippets of
scripting code are injected and later executed when returned back from a
server. The typical scenario is that of a website with a search field
that does not validate its input, and returns an error message that
includes the value that was submitted. If the value includes a snippet
of the form ...</script> then it will be executed by the browser when
the page containing the error is rendered.

There are lots of different variations of this the XSS attack, but most
can be prevented by ensuring that the data submitted by clients is
properly _sanitized_ before it is manipulated, stored in a database,
returned to the client, etc. Data escaping/encoding is the recommended
way to deal with untrusted data and prevent XSS attacks.

MVC applications can gain access to encoders through the MvcContext
object; the methods defined by javax.mvc.security.Encoders can be used
by applications to contextually encode data in an attempt to prevent XSS
attacks. The reader is referred to the Javadoc for this type for further
information.

[[events]]
Events
------

This chapter introduces a mechanism by which MVC applications can be
informed of important events that occur while processing a request. This
mechanism is based on CDI events that can be fired by implementations
and observed by applications.

[[observers]]
Observers
~~~~~~~~~

The package `javax.mvc.event` defines a number of event types that MUST
be fired by implementations during the processing of a request
*latexmath:[$[\![$][mvc:event-firing]latexmath:[$]\!]$]*.
Implementations MAY extend this set and also provide additional
information on any of the events defined by this specification. The
reader is referred to the implementation’s documentation for more
information on event support.

Observing events can be useful for applications to learn about the
lifecycle of a request, perform logging, monitor performance, etc. The
events `BeforeControllerEvent` and `AfterControllerEvent` are fired
around the invocation of a controller; applications can monitor these
events using an observer as shown next.

1 @ApplicationScoped public class EventObserver

public void onBeforeController(@Observes BeforeControllerEvent e)
System.out.println(``URI: '' + e.getUriInfo().getRequestURI());

public void onAfterController(@Observes AfterControllerEvent e)
System.out.println(``Controller: '' +
e.getResourceInfo().getResourceMethod());

Observer methods in CDI are defined using the `@Observes` annotation on
a parameter position. The class `EventObserver` is a CDI bean in
application scope whose methods `onBeforeController` and
`onAfterController` are called before and after a controller is called.

Every event generated must include a unique ID whose getter is defined
in `MvcEvent`, the base type for all events. Moreover, each event
includes additional information that is specific to the event; for
example, the events shown in the example above allow applications to get
information about the request URI and the resource (controller)
selected.

Chapter [view_engines] describes the algorithm used by implementations
to select a specific view engine for processing; after a view engine is
selected, the method `processView` is called. The events
`BeforeProcessViewEvent` and `AfterProcessViewEvent` are fired around
this call and can be observed in a similar manner:

1 @ApplicationScoped public class EventObserver

public void onBeforeProcessView(@Observes BeforeProcessViewEvent e) ...

public void onAfterProcessView(@Observes AfterProcessViewEvent e) ...

To complete the example, let us assume that the information about the
selected view engine needs to be conveyed to the client. To ensure that
this information is available to a view returned to the client, the
`EventObserver` class can inject and update the same request-scope bean
accessed by such a view:

1 @ApplicationScoped public class EventObserver

@Inject private EventBean eventBean;

public void onBeforeProcessView(@Observes BeforeProcessViewEvent e)
eventBean.setView(e.getView()); eventBean.setEngine(e.getEngine());

...

For more information about the interaction between views and models, the
reader is referred to Section [models].

CDI events fired by implementations are _synchronous_, so it is
recommended that applications carry out only simple tasks in their
observer methods, avoiding long-running computations as well as blocking
calls. For a complete list of events, the reader is referred to the
Javadoc for the `javax.mvc.event` package.

Event reporting requires the MVC implementations to create event objects
before firing. In high-throughput systems without any observers the
number of unnecessary objects created may not be insignificant. For this
reason, it is RECOMMENDED for implementations to consider smart firing
strategies when no observers are present.

[[view_engines]]
View Engines
------------

This chapter introduces the notion of a view engine as the mechanism by
which views are processed in MVC. The set of available view engines is
extensible via CDI, enabling applications as well as other frameworks to
provide support for additional view languages.

[[view_engines_introduction]]
Introduction
~~~~~~~~~~~~

A _view engine_ is responsible for processing views. In this context,
processing entails (i) locating and loading a view (ii) preparing any
required models and (iii) rendering the view and writing the result back
to the client.

Implementations MUST provide built-in support for JSPs and Facelets view
engines *latexmath:[$[\![$][mvc:builtin-engines]latexmath:[$]\!]$]*.
Additional engines may be supported via an extension mechanism based on
CDI. Namely, any CDI bean that implements the
`javax.mvc.engine.ViewEngine` interface MUST be considered as a possible
target for processing by calling its `supports` method, discarding the
engine if this method returns `false`
*latexmath:[$[\![$][mvc:extension-engines]latexmath:[$]\!]$]*.

This is the interface that must be implemented by all MVC view engines:

1 public interface ViewEngine

boolean supports(String view);

void processView(ViewEngineContext context) throws ViewEngineException;

[[selection_algorithm]]
Selection Algorithm
~~~~~~~~~~~~~~~~~~~

As explained in Section [viewable], a `Viewable` is an encapsulation for
information that relates to a view. Every possible return type from a
controller method is either a `Viewable` or can be turned into one by
calling a constructor. Thus, the following algorithm assumes only
`Viewable` as input.

Implementations should perform the following steps while trying to find
a suitable view engine for a
`Viewable` *latexmath:[$[\![$][mvc:selection-algorithm]latexmath:[$]\!]$]*.

1.  If calling `getViewEngine` on the `Viewable` returns a non-null
value, return that view engine.
2.  Otherwise, lookup all instances of `javax.mvc.engine.ViewEngine`
available via CDI. footnote:[The `@Any` annotation in CDI can be used
for this purpose.]
3.  Call `supports` on every view engine found in the previous step,
discarding those that return `false`.
4.  If the resulting set is empty, return `null`.
5.  Otherwise, sort the resulting set in descending order of priority
using the integer value from the `@Priority` annotation decorating the
view engine class or the default value `Priorities.DEFAULT` if the
annotation is not present.
6.  Return the first element in the resulting sorted set, that is, the
view engine with the highest priority that supports the given
`Viewable`.

If a view engine that can process a `Viewable` is not found, as a
fall-back attempt to process the view by other means, implementations
are REQUIRED to forward the request-response pair back to the Servlet
container using a `RequestDispatcher`
*latexmath:[$[\![$][mvc:request-forward]latexmath:[$]\!]$]*.

The `processView` method has all the information necessary for
processing in the `ViewEngineContext`, including the view, a reference
to `Models`, as well as the HTTP request and response from the
underlying the Servlet container. Implementations MUST catch exceptions
thrown during the execution of `processView` and re-throw them as
`ViewEngineException`’s
*latexmath:[$[\![$][mvc:exception-wrap]latexmath:[$]\!]$]*.

Prior to the view render phase, all entries available in `Models` MUST
be bound in such a way that they become available to the view being
processed. The exact mechanism for this depends on the actual view
engine implementation. In the case of the built-in view engines for JSPs
and Facelets, entries in `Models` must be bound by calling
`HttpServletRequest.setAttribute(String, Object)`; calling this method
ensures access to the named models from EL expressions.

A view returned by a controller method represents a path within an
application archive. If the path is relative, does not start with `/`,
implementations MUST resolve view paths relative to value of
`ViewEngine. DEFAULT_VIEW_FOLDER`, which is set to `/WEB-INF/views/`. If
the path is absolute, no further processing is required
*latexmath:[$[\![$][mvc:view-resolution]latexmath:[$]\!]$]*. It is
recommended to use relative paths and a location under `WEB-INF` to
prevent direct access to views as static resources.

[[faces_servlet]]
FacesServlet
~~~~~~~~~~~~

Because Facelets support is not enabled by default, MVC applications
that use Facelets are required to package a `web.xml` deployment
descriptor with the following entry mapping the extension `.xhtml` as
shown next:

1 <servlet> <servlet-name>Faces Servlet</servlet-name>
<servlet-class>javax.faces.webapp.FacesServlet</servlet-class>
<load-on-startup>1</load-on-startup> </servlet> <servlet-mapping>
<servlet-name>Faces Servlet</servlet-name>
<url-pattern>*.xhtml</url-pattern> </servlet-mapping>

It is worth noting that if you opt to use Facelets as a view technology
for your MVC application, regular JSF post-backs will not be processed
by the MVC runtime. The usage of `` and depending form components like
`` is not recommended as they would be the entry point to a real JSF
application.

[[i18n]]
Internationalization
--------------------

This chapter introduces the notion of a _request locale_ and describes
how MVChandles internationalization and localization.

[[i18n_introduction]]
Introduction
~~~~~~~~~~~~

Internationalization and localization are very important concepts for
any web application framework. Therefore MVC has been designed to make
supporting multiple languages and regional differences in applications
very easy.

MVC defines the term _request locale_ as the locale which is used for
any locale-dependent operation within the lifecycle of a request. The
request locale MUST be resolved exactly once for each request using the
resolving algorithm described in Section [i18n_resolving_algorithm].

These locale-dependent operations include, but are not limited to:

1.  Data type conversion as part of the data binding mechanism.
2.  Formatting of data when rendering it to the view.
3.  Generating binding and validation error messages in the specific
language.

The request locale is available from `MvcContext` and can be used by
controllers, view engines and other components to perform operations
which depend on the current locale
*latexmath:[$[\![$][mvc:request-locale-context]latexmath:[$]\!]$]*. The
example below shows a controller that uses the request locale to create
a `NumberFormat` instance.

1 @Controller @Path(``/foobar'') public class MyController

@Inject private MvcContext mvc;

@GET public String get()

Locale locale = mvc.getLocale(); NumberFormat format =
NumberFormat.getInstance(locale);

The following sections will explain the locale resolving algorithm and
the default resolver provided by the MVC implementation.

[[i18n_resolving_algorithm]]
Resolving Algorithm
~~~~~~~~~~~~~~~~~~~

The _locale resolver_ is responsible to detect the request locale for
each request processed by the MVC runtime. A locale resolver MUST
implement the `javax.mvc.locale.LocaleResolver` interface which is
defined like this:

1 public interface LocaleResolver

Locale resolveLocale(LocaleResolverContext context);

There may be more than one locale resolver for a MVC application. Locale
resolvers are discovered using CDI
*latexmath:[$[\![$][mvc:extension-resolvers]latexmath:[$]\!]$]*. Every
CDI bean implementing the `LocaleResolver` interface and visible to the
application participates in the locale resolving algorithm.

Implementations MUST use the following algorithm to resolve the request
locale for each request
*latexmath:[$[\![$][mvc:resolve-algorithm]latexmath:[$]\!]$]*:

1.  Obtain a list of all CDI beans implementing the `LocaleResolver`
interface visible to the application’s `BeanManager`.
2.  Sort the list of locale resolvers in descending order of priority
using the integer value from the `@Priority` annotation decorating the
resolver class. If no `@Priority` annotation is present, assume a
default priority of `1000`.
3.  Call `resolveLocale()` on the first resolver in the list. If the
resolver returns `null`, continue with the next resolver in the list. If
a resolver returns a non-null result, stop the algorithm and use the
returned locale as the request locale.

Applications can either rely on the default locale resolver which is
described in Section [i18n_default_resolver] or provide a custom
resolver which implements some other strategy for resolving the request
locale. A custom strategy could for example track the locale using the
session, a query parameter or the server’s hostname.

[[i18n_default_resolver]]
Default Locale Resolver
~~~~~~~~~~~~~~~~~~~~~~~

Every MVC implementation MUST provide a default locale resolver with a
priority of `0` which resolves the request locale according to the
following algorithm
*latexmath:[$[\![$][mvc:default-locale-resolver]latexmath:[$]\!]$]*:

1.  First check whether the client provided an `Accept-Language` request
header. If this is the case, the locale with the highest quality factor
is returned as the result.
2.  If the previous step was not successful, return the system default
locale of the server.

Please note that applications can customize the locale resolving process
by providing a custom locale resolver with a priority higher than `0`.
See Section [i18n_resolving_algorithm] for details.

[[annotation_table]]
Summary of Annotations
----------------------

[cols="<,<,<",]
|=======================================================================
|*Annotation & *Target & *Description `Controller` & Type or method &
Defines a resource method as an MVC controller. If specified at the type
level, it defines all methods in a class as controllers. `View` & Type
or method & Declares a view for a controller method that returns void.
If specified at the type level, it applies to all controller methods
that return void in a class. `CsrfValid` & Method & States that a CSRF
token must be validated before invoking the controller. Failure to
validate the CSRF token results in a ForbiddenException thrown.
`RedirectScoped` & Type, method or field & Specifies that a certain bean
is in redirect scope. `UriRef` & Method & Defines a symbolic name for a
controller method.*** | |
|=======================================================================

[[change-log]]
Change Log
----------

[[changes-since-1.0-early-draft]]
Changes Since 1.0 Early Draft
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* Section [binding_exceptions] New section related to the use of
BindingResult to handle binding errors.
* Section [validation_exceptions] The type ValidationResult renamed to
BindingResult after extending its scope to binding errors as well.
* Section [redirect] Introduce the redirect scope and related
annotation.
* Section [mvc_context]: New section about injectable MvcContext.
* Chapter [security]: New chapter about security.
* Section [faces_servlet]: New section about `FacesServlet` and its
configuration.
* Chapter [events]: Updated based on changes to `javax.mvc.event`
package.
* Section [annotation_inheritance]: New section on annotation
inheritance rules.
* Section [redirect]: New section about HTTP redirects.
* Section [controllers]: Allow `@View` to be used for controller methods
returning a `null` value.
* Section [controllers]: Controller methods can return arbitrary Java
types on which `toString` is called, interpreting the result as a view
path.
* Section [controllers]: Updated return type sample using unique paths.
* Section [i18n]: New chapter about internationalization.
* Section [controllers]: Clarified that Sub-resource locators are not
supported.
* Appendix [annotation_table]: Added UriRef annotation.
* Section [controllers]: Added a facelets example and a warning about
the usage of in section [view_engines].

[[assertions]]
Summary of Assertions
---------------------

itemlabel*latexmath:[$[\![$]mvc:controllerlatexmath:[$]\!]$]*

currentlabelmvc:controller[mvc:controller]

Controller methods are JAX-RS resource methods annotated with
`@Controller`.

itemlabel*latexmath:[$[\![$]mvc:all-controllerslatexmath:[$]\!]$]*

currentlabelmvc:all-controllers[mvc:all-controllers]

All resource methods in a class annotated with `@Controller` must be
controllers.

itemlabel*latexmath:[$[\![$]mvc:void-controllerslatexmath:[$]\!]$]*

currentlabelmvc:void-controllers[mvc:void-controllers]

Controller methods that return void must be annotated with `@View`.

itemlabel*latexmath:[$[\![$]mvc:cdi-beanslatexmath:[$]\!]$]*

currentlabelmvc:cdi-beans[mvc:cdi-beans]

MVC beans are managed by CDI.

itemlabel*latexmath:[$[\![$]mvc:per-requestlatexmath:[$]\!]$]*

currentlabelmvc:per-request[mvc:per-request]

Default scope for MVC beans is request scope.

itemlabel*latexmath:[$[\![$]mvc:validation-resultlatexmath:[$]\!]$]*

currentlabelmvc:validation-result[mvc:validation-result]

If validation fails, controller methods must still be called if a
`ValidationResult` field or property is defined.

itemlabel*latexmath:[$[\![$]mvc:event-firinglatexmath:[$]\!]$]*

currentlabelmvc:event-firing[mvc:event-firing]

All events in `javax.mvc.event` must be fired. See Javadoc for more
information on each event in that package.

itemlabel*latexmath:[$[\![$]mvc:builtin-engineslatexmath:[$]\!]$]*

currentlabelmvc:builtin-engines[mvc:builtin-engines]

Implementations must provide support for JSPs and Facelets.

itemlabel*latexmath:[$[\![$]mvc:extension-engineslatexmath:[$]\!]$]*

currentlabelmvc:extension-engines[mvc:extension-engines]

CDI beans that implement `javax.mvc.engine.ViewEngine` provide an
extension mechanism for view engines.

itemlabel*latexmath:[$[\![$]mvc:selection-algorithmlatexmath:[$]\!]$]*

currentlabelmvc:selection-algorithm[mvc:selection-algorithm]

Implementations must use algorithm in Section [selection_algorithm] to
select view engines.

itemlabel*latexmath:[$[\![$]mvc:request-forwardlatexmath:[$]\!]$]*

currentlabelmvc:request-forward[mvc:request-forward]

Forward request for which no view engine is found.

itemlabel*latexmath:[$[\![$]mvc:exception-wraplatexmath:[$]\!]$]*

currentlabelmvc:exception-wrap[mvc:exception-wrap]

Exceptions thrown during view processing must be wrapped.

itemlabel*latexmath:[$[\![$]mvc:view-resolutionlatexmath:[$]\!]$]*

currentlabelmvc:view-resolution[mvc:view-resolution]

Relative paths to views must be resolved as explained in Section
[selection_algorithm].

itemlabel*latexmath:[$[\![$]mvc:null-controllerslatexmath:[$]\!]$]*

currentlabelmvc:null-controllers[mvc:null-controllers]

The `@View` annotation is treated as a default value for any controller
method that returns a `null` value.

itemlabel*latexmath:[$[\![$]mvc:redirectlatexmath:[$]\!]$]*

currentlabelmvc:redirect[mvc:redirect]

Support HTTP redirects using the redirect: prefix and a controller
return type of String.

itemlabel*latexmath:[$[\![$]mvc:annotation-inheritancelatexmath:[$]\!]$]*

currentlabelmvc:annotation-inheritance[mvc:annotation-inheritance]

Annotation inheritance is derived from JAX-RS  and extended to
MVC annotations.

itemlabel*latexmath:[$[\![$]mvc:csrf-optionslatexmath:[$]\!]$]*

currentlabelmvc:csrf-options[mvc:csrf-options]

CSRF support for configuration options defined by Csrf.CsrfOptions.

itemlabel*latexmath:[$[\![$]mvc:csrf-supportlatexmath:[$]\!]$]*

currentlabelmvc:csrf-support[mvc:csrf-support]

CSRF validation required only for controllers annotated by @POST and
consuming the media type x-www-form-urlencoded.

itemlabel*latexmath:[$[\![$]mvc:mvc-contextlatexmath:[$]\!]$]*

currentlabelmvc:mvc-context[mvc:mvc-context]

Application-scoped MvcContext available for injection and as mvc in EL.

itemlabel*latexmath:[$[\![$]mvc:request-locale-contextlatexmath:[$]\!]$]*

currentlabelmvc:request-locale-context[mvc:request-locale-context]

The `MvcContext` must provide access to the current request locale.

itemlabel*latexmath:[$[\![$]mvc:extension-resolverslatexmath:[$]\!]$]*

currentlabelmvc:extension-resolvers[mvc:extension-resolvers]

CDI beans implementing `javax.mvc.locale.LocaleResolver` provide an
extension mechanism for the request locale resolving algorithm.

itemlabel*latexmath:[$[\![$]mvc:resolve-algorithmlatexmath:[$]\!]$]*

currentlabelmvc:resolve-algorithm[mvc:resolve-algorithm]

The request locale must be resolved as described in Section
[i18n_resolving_algorithm].

itemlabel*latexmath:[$[\![$]mvc:default-locale-resolverlatexmath:[$]\!]$]*

currentlabelmvc:default-locale-resolver[mvc:default-locale-resolver]

Implementations must provide a default locale resolver as described in
Section [i18n_default_resolver].
